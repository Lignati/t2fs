#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "../include/apidisk.h"
#include "../include/bitmap2.h"
#include "../include/t2fs.h"

struct t2fs_inode diretorioAtualInode;
struct t2fs_superbloco superBloco;
struct t2fs_inode diretorioRaizInode;
char * blocoAtual;
int blocoInodesInicial;
int tamanhoBlocoBytes;
int tamanhoBloco;
int numeroRecords;
int initFlag = 0;
// funcao recebe duas strigs retrona na segunda o correspondente ao diretorio atual e na primeira o correspondente ao resto do caminho
void caminhoParcial(char * stringTotal, char * stringParcial){
	int i,shift;
	char stringNovoPath[59];
	
	i = 0;
		
	if(stringTotal[0] == '/'){
		i++;
		
		
	}
	else{
		while(stringTotal[i] != '\0' && stringTotal[i] != '/'){
			stringParcial[i] = stringTotal[i];
			i++;
		}
		stringParcial[i] = '\0'; 
		
	}

	shift = 0;

	if(stringTotal[i] == '\0'){
		strcpy(stringTotal,"\0");
		return;
	}
	i++;
	
	while(stringTotal[i] != '\0'){
		
		stringNovoPath[shift] = stringTotal[i];
		shift++;i++;
	}
	
	stringNovoPath[shift] = '\0';

	strcpy(stringTotal,stringNovoPath);

}
//carrega o super bloco e faz os calculos iniciais das variaveis globais, deve estar na init()	
void carregaSuperBloco(){
	char buffer[SECTOR_SIZE];

	read_sector (0, buffer);
	//copia do setor para a estrutura global
	memcpy((void *)&(superBloco.id),                  (void*)&buffer[0] ,4);
	memcpy((void *)&(superBloco.version),             (void*)&buffer[4] ,2);
	memcpy((void *)&(superBloco.superblockSize),      (void*)&buffer[6] ,2);
	memcpy((void *)&(superBloco.freeBlocksBitmapSize),(void*)&buffer[8] ,2);
	memcpy((void *)&(superBloco.freeInodeBitmapSize), (void*)&buffer[10],2);
	memcpy((void *)&(superBloco.inodeAreaSize),       (void*)&buffer[12],2);
	memcpy((void *)&(superBloco.blockSize),           (void*)&buffer[14],2);
	memcpy((void *)&(superBloco.diskSize),            (void*)&buffer[16],4);
	//inicia as varaiveis globais
	blocoInodesInicial  = superBloco.superblockSize + superBloco.freeBlocksBitmapSize + superBloco.freeInodeBitmapSize;
	tamanhoBlocoBytes   = SECTOR_SIZE * superBloco.blockSize;
	tamanhoBloco        = superBloco.blockSize;
	numeroRecords       = tamanhoBlocoBytes/RECORD_SIZE;
	



}

void iniciaBloco(){
	int i;
	blocoAtual  = (char *) malloc (sizeof(char)*SECTOR_SIZE*tamanhoBloco);

}
/*
funcao que inicia no heap(malloc) o veotr que contera o bloco atualmente carregado, deve estar na init(), acessar o bloco pela variavel
global ablocoAtual
*/
void carregaBloco(int i){
	char buffer[SECTOR_SIZE];
	int n,j;
	n = i*tamanhoBloco;
	for(j = 0; j<tamanhoBloco;j++){
		read_sector (n+j, buffer);
		memcpy((void*)&blocoAtual[SECTOR_SIZE*j],            (void*)&buffer[0],SECTOR_SIZE);
	}
}

void printSuperBloco(){
	
	printf("ID:%c %c %c %c \n",superBloco.id[0],superBloco.id[1],superBloco.id[2],superBloco.id[3]);
	printf("Version:%X \n",superBloco.version);
	printf("SuperBlockBitmap:%d \n",superBloco.superblockSize);
	printf("FreeBlockBitMap:%d \n",superBloco.freeBlocksBitmapSize);
	printf("FreeiNodeBitmap:%d \n",superBloco.freeInodeBitmapSize);
	printf("iNodeArea:%d \n",superBloco.inodeAreaSize);
	printf("BlockSize:%d \n",superBloco.blockSize);
	printf("DiskSize:%d \n",superBloco.diskSize);


}

//retorna uma estrutura inode e le o inode referente ao numero passado como parametro
struct t2fs_inode leInode(int n){
	struct t2fs_inode iNode;
	
	int pos;
	carregaBloco(blocoInodesInicial+((int)n/32));
	//printf("bloco carregado\n");
	pos = n*32;

	memcpy((void *)&(iNode.blocksFileSize),            (void*)&blocoAtual[pos]    ,4);
	memcpy((void *)&(iNode.bytesFileSize),             (void*)&blocoAtual[pos+4]  ,4);
	memcpy((void *)&(iNode.dataPtr[0]),                (void*)&blocoAtual[pos+8]  ,4);
	memcpy((void *)&(iNode.dataPtr[1]),                (void*)&blocoAtual[pos+12] ,4);
	memcpy((void *)&(iNode.singleIndPtr),              (void*)&blocoAtual[pos+16] ,4);
	memcpy((void *)&(iNode.doubleIndPtr),              (void*)&blocoAtual[pos+20] ,4);
	memcpy((void *)&(iNode.reservado),                 (void*)&blocoAtual[pos+24] ,8);	
		
	return iNode;
	

}

void printInode(struct t2fs_inode iNode){
	printf("\nSize in Blocks %d\n",iNode.blocksFileSize);
	printf("Size in Bytes %d\n",iNode.bytesFileSize);
	printf("Data ptr 1 %u\n",iNode.dataPtr[0]);
	printf("Data ptr 2 %u\n",iNode.dataPtr[1]);
	printf("Ptr Ind Simples %u\n",iNode.singleIndPtr);
	printf("Ptr Ind Dupla %u\n\n",iNode.doubleIndPtr);


}

struct t2fs_inode readAndPrintDir(struct t2fs_inode diretorioInode){
	struct t2fs_record record;
	int i;			
	if(diretorioInode.blocksFileSize > 0){
		carregaBloco(diretorioInode.dataPtr[0]);

		for(i = 0; i < numeroRecords; i++) {
			memcpy((void*)&record,(void *)&blocoAtual[i*64],sizeof(struct t2fs_record));
			if(record.TypeVal == TYPEVAL_REGULAR || record.TypeVal == TYPEVAL_DIRETORIO){
				printf("TypeVal: %X\n",record.TypeVal);
				printf("Name: %s\n",record.name);
				printf("iNodeNumber: %d\n",record.inodeNumber);
		
				printf("----------------------------------------------------------------------\n");
			}
		}
	}
	if(diretorioInode.blocksFileSize > 1){
		int i;
		carregaBloco(diretorioInode.dataPtr[1]);
		if(record.TypeVal == TYPEVAL_REGULAR || record.TypeVal == TYPEVAL_DIRETORIO){
			for(i = 0; i < numeroRecords; i++) {
				memcpy((void*)&record,(void *)&blocoAtual[i*64],sizeof(struct t2fs_record));
				printf("TypeVal: %X\n",record.TypeVal);
				printf("Name: %s\n",record.name);
				printf("iNodeNumber: %d\n",record.inodeNumber);
		
				printf("----------------------------------------------------------------------\n");
			}
		}
	}
	if(diretorioInode.blocksFileSize > 2){

		printf("leitura de indirecao\n");

	}
}
//usado para achar em algum caminho(absoluto ou relativo) um arquivo regular, retorna o numero do inode do arquivo
int findFile(struct t2fs_inode diretorioInode,char * nome){
	struct t2fs_record record;
	int i;
	char partialPath[59];
	if(nome[0] == '/'){
		diretorioInode = diretorioRaizInode;
		i = 1;
		while(nome[i] != '\0'){	
			nome[i-1] = nome[i];
			i++;	
		}
		nome[i-1] = '\0';
	}
	caminhoParcial(nome,partialPath);
	if(diretorioInode.blocksFileSize > 0){
		carregaBloco(diretorioInode.dataPtr[0]);
		for(i = 0; i < numeroRecords; i++) {

			memcpy((void*)&record,(void *)&blocoAtual[i*64],sizeof(struct t2fs_record));
			if(record.TypeVal == TYPEVAL_REGULAR && strcmp(partialPath,record.name) == 0){
				return record.inodeNumber;

			}
			if(record.TypeVal == TYPEVAL_DIRETORIO && strcmp(partialPath,record.name) == 0){
				return findFile(leInode(record.inodeNumber),nome);
			}
		}
	}
	if(diretorioInode.blocksFileSize > 1){	
		carregaBloco(diretorioInode.dataPtr[1]);
		for(i = 0; i < numeroRecords; i++) {
			memcpy((void*)&record,(void *)&blocoAtual[i*64],sizeof(struct t2fs_record));
			if(record.TypeVal == TYPEVAL_REGULAR && strcmp(partialPath,record.name) == 0){
				return record.inodeNumber;
			}
			if(record.TypeVal == TYPEVAL_DIRETORIO && strcmp(partialPath,record.name) == 0){
				return findFile(leInode(record.inodeNumber),nome);
			}
		}
	}
	if(diretorioInode.blocksFileSize > 2){
		printf("leitura de indirecao)");
	}
	return -1;
}
//usado para achar em algum caminho(absoluto ou relativo) um arquivo diretorio, retorna o numero do inode do diretorio
int findDir(struct t2fs_inode diretorioInode,char * nome){
	struct t2fs_record record;
	int i;
	char partialPath[59];
	

	if(nome[0] == '/'){
		diretorioInode = diretorioRaizInode;
		i = 1;
		while(nome[i] != '\0'){	
			nome[i-1] = nome[i];
			i++;	
		}
		nome[i-1] = '\0';
	}
	caminhoParcial(nome,partialPath);
	printf("Nome:%s PartialPath %s \n",nome,partialPath);
	printf("\n",record.name);
	if(diretorioInode.blocksFileSize > 0){
		carregaBloco(diretorioInode.dataPtr[0]);
		for(i = 0; i < numeroRecords; i++) {

			memcpy((void*)&record,(void *)&blocoAtual[i*64],sizeof(struct t2fs_record));

			if(record.TypeVal == TYPEVAL_DIRETORIO && strcmp(partialPath,record.name) == 0){

				if(nome[0] == '\0'){
		
					return record.inodeNumber;
				}
				return findDir(leInode(record.inodeNumber),nome);
			}
		}
	}
	if(diretorioInode.blocksFileSize > 1){	
		carregaBloco(diretorioInode.dataPtr[1]);
		for(i = 0; i < numeroRecords; i++) {
			memcpy((void*)&record,(void *)&blocoAtual[i*64],sizeof(struct t2fs_record));
			if(record.TypeVal == TYPEVAL_DIRETORIO && strcmp(partialPath,record.name) == 0){
				return findDir(leInode(record.inodeNumber),nome);
			}
		}
	}
	if(diretorioInode.blocksFileSize > 2){
		printf("leitura de indirecao)");
	}
	return -1;
}


/*
Função que retorna o bloco que encontra-se no endereço passado por parametro.
Ex:
bloco = getBloco(iNode.singleIndPtr);
*/
char * getBloco(int i){
char buffer[256];
char * bloco = (char *) malloc (sizeof(char)*1024);
int n;
n = (i*4);
read_sector (n, buffer);
memcpy((void*)&bloco[0], (void*)&buffer[0],256);
read_sector (n+1, buffer);
memcpy((void*)&bloco[SECTOR_SIZE*1],(void*)&buffer[0],256);
read_sector (n+2, buffer);
memcpy((void*)&bloco[SECTOR_SIZE*2],(void*)&buffer[0],256);
read_sector (n+3, buffer);
memcpy((void*)&bloco[SECTOR_SIZE*3],(void*)&buffer[0],256);
return bloco;
}
/*
Função que retorna uma lista do tipo list[iNode.blocksFileSize] contendo
todos os ponteiros diretos que formam o arquivo.
*/
DWORD* getListPointer(struct t2fs_inode iNode){
	//DWORD listBloc[iNode.blocksFileSize];
	DWORD * listBloc = (DWORD *) calloc (iNode.blocksFileSize, sizeof (DWORD));	
	char * bloco = (char *) malloc (sizeof(char)*1024);
	char * blocoInd = (char *) malloc (sizeof(char)*1024);
	int i;
	int contPoint = 0;
	int PointerPerBloc = sizeof(bloco)/sizeof(DWORD); //quantidade de ponteiros que cabe em um bloco
	DWORD * listPointerInd = (DWORD *) calloc (PointerPerBloc, sizeof (DWORD));	


	
	//Blocos endereçados diretamente.
	if (iNode.blocksFileSize == 1){
		listBloc[0] = iNode.dataPtr[0];
		contPoint++;
	}
	if (iNode.blocksFileSize == 2){
		listBloc[1] = iNode.dataPtr[1];
		contPoint++;
	}
	
	//Indireção simples.
	if (iNode.singleIndPtr != INVALID_PTR){
		bloco = getBloco(iNode.singleIndPtr);			
		for (i = 0; i <= PointerPerBloc && contPoint < iNode.blocksFileSize; i++){			
			memcpy((void *)&(listBloc[contPoint]), (void*)&bloco[4*(i)],4);			
			contPoint++;
		}				
	}
	int contBlocInd = 0;
	DWORD blocoDi;
	//Indireção Dupla
	if (iNode.doubleIndPtr != INVALID_PTR){
		//blocoInd é o bloco de indireção nível 1
		blocoInd = getBloco(iNode.doubleIndPtr);	
		while(contPoint < iNode.blocksFileSize){			
			//blocoDi é o endereço do bloco de nível 2 da indireção. Ou seja,
			//o bloco que contem os ponteiros dos blocos de dados
			memcpy((void *)&(blocoDi), (void*)&bloco[4*(contBlocInd)],4);
			contBlocInd++;		
			bloco = getBloco(blocoDi);
			for (i = 0; i <= PointerPerBloc && contPoint < iNode.blocksFileSize; i++){			
				memcpy((void *)&(listBloc[contPoint]), (void*)&bloco[4*(i)],4);			
				contPoint++;
			}
		}
		
	}
	
	
	
	
	for(i = 0; i< iNode.blocksFileSize; i++){
		printf("%d - ", listBloc[i]);
	}
	
	return listBloc;
	
	
}
//faz as inicializacoes da lib, 'e chamada no comeco de todas as funcoes de usuario
void init(){
	if (init ==0);
		carregaSuperBloco();
		iniciaBloco();
		diretorioRaizInode  = leInode(0);
		diretorioAtualInode = leInode(0);
	initFlag =1;


}









/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////FUNCOES DE USUARIO/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FILE2 open2 (char *filename){

	init();
	/*todo lista de handles*/
	return findFile(diretorioAtualInode,filename);
}
DIR2 opendir2 (char *pathname){
	init();
	/*todo lista de handles*/
	return findDir(diretorioAtualInode,pathname);


}
int chdir2(char *pathname){

	diretorioAtualInode = leInode(findDir(diretorioAtualInode,pathname));	

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////MAIN PARA TESTES/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int main(){
	char file [] = "dir1/../file3";

	int i;
	init();
	printInode(leInode(6));
	printf("%d\n",findFile(diretorioRaizInode,file));
	printf("\nFIM EXECUCAO\n");
	
	return 0;
}



	/*
	for (j = 0; j < 5; j++ ){
		if (getBitmap2(0,j) == 1){
			inode = leInode(j);
			printf("inode: %d ---> " , j);
			listBloc = getListPointer(inode);
			printf("fim getListPointer...\n");
			//if (inode.blocksFileSize > 2)
			//	printf("inode: %d", i);
			//printf("inode lido...\n");
			//printInode(leInode(i));
		}			
	}
	*/
	
